---
layout:     post
title:      Mysql系列-5
subtitle:   Mysql详解
date:       2021-06-30
author:     CodingAndLiving
header-img: img/com01.jpg
catalog: true
tags:
    - Mysql
    - 原理
    - 底层
---
# 前言

> 在繁杂的世界，能够沉下心来，梳理下知识体系，其实是一件很放松的诗意。

ps：迷信也好，什么也罢，这里不想用数字4，所以采用5了。 

# 事务及其ACID属性 
事务是由一组SQL语句组成的逻辑处理单元,事务具有以下4个属性,通常简称为事务的ACID属性。 

原子性(Atomicity) ：事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。 

一致性(Consistent) ：在事务开始和完成时,数据都必须保持一致状态。这意味着所有相关的数据规 则都必须应用于事务的修改,以保持数据的完整性。 

隔离性(Isolation) ：数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独 立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。 

持久性(Durable) ：事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。

> tips：如何理解掌握上面的定义，必须抓住**关键字**事务。

# 并发事务处理带来的问题 

更新丢失(Lost Update)或脏写 

当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存 在，就会发生丢失更新问题–**最后的更新覆盖了由其他事务所做的更新**。 

脏读（Dirty Reads） 

一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致的状态；这 时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此作进一步的 处理，就会产生未提交的数据依赖关系。这种现象被形象的叫做“脏读”。 

一句话：**事务A读取到了事务B已经修改但尚未提交的数据，还在这个数据基础上做了操作。此时，如果B 事务回滚，A读取的数据无效，不符合一致性要求**。

不可重读（Non-Repeatable Reads） 

一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改 变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。 

一句话：**事务A内部的相同查询语句在不同时刻读出的结果不一致，不符合隔离性**

幻读（Phantom Reads） 

一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数 据，这种现象就称为“幻读”。 

一句话：**事务A读取到了事务B提交的新增数据，不符合隔离性**


> tips：大佬，记得抓住关键字**事务**

# 事务隔离级别 
“脏读”、“不可重复读”和“幻读”,其实都是数据库读一致性问题,必须由数据库提供一定的事务隔离机制 来解决。

1. 读未提交： 不能解决脏读、不可重复读、幻读等问题。

2. 读已提交：略微好点，能够解决脏读。

3. 可重复读：更好点，可以解决不可重复读问题了。

4. 可串行化：完美，都可以解决。

数据库的事务隔离越严格,并发副作用越小,但付出的代价也就越大,因为事务隔离实质上就是使事务在一定程度 上“串行化”进行,这显然与“并发”是矛盾的。 同时,不同的应用对读一致性和事务隔离程度的要求也是不同的,比如许多应用对“不可重复读"和“幻读”并不 敏感,可能更关心数据并发访问的能力。 

常看当前数据库的事务隔离级别: 

> show variables like 'tx_isolation'; 

设置事务隔离级别：

> set tx_isolation='REPEATABLE-READ'; 

Mysql默认的事务隔离级别是**可重复读**，用Spring开发程序时，如果不设置隔离级别默认用Mysql设置的隔 离级别，如果Spring设置了就用已经设置的隔离级别


# 锁分类 
从性能上分为乐观锁(用版本对比来实现)和悲观锁 

从对数据库操作的类型分，分为读锁和写锁(都属于悲观锁) 

读锁（共享锁，S锁(Shared)）：针对同一份数据，多个读操作可以同时进行而不会互相影响 

写锁（排它锁，X锁(eXclusive)）：当前写操作没有完成前，它会阻断其他写锁和读锁 

从对数据操作的粒度分，分为表锁和行锁

## 表锁
每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低； 一般用在整表数据迁移的场景。

手动增加表锁 

> lock table 表名称 read(write),表名称2 read(write); 

查看表上加过的锁 

> show open tables; 

删除表锁 

> unlock tables;


## 行锁
每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最 高。

InnoDB与MYISAM的最大不同有两点： 

1. InnoDB支持事务（TRANSACTION） 
2. InnoDB支持行级锁 

行锁演示 

一个session开启事务更新不提交，另一个session更新同一条记录会阻塞，更新不同记录不会阻塞


> MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁,在执行update、insert、delete操作会自 动给涉及的表加写锁。 

> InnoDB在执行查询语句SELECT时(非串行隔离级别)，不会加锁。但是update、insert、delete操作会加行 锁

> 在串行模式下innodb的查询也会被加上行锁。 如果客户端A执行的是一个范围查询，那么该范围内的所有行包括每行记录所在的间隙区间范围(就算该行数据 还未被插入也会加锁，这种是间隙锁)都会被加锁。此时如果客户端B在该范围内插入数据都会被阻塞，所以就 避免了幻读


假设表Account,涉及两个字段，id、name
此刻含有数据如下

```
1，xx
2, bb
3, ee
10,ww
20,uo
```


那么间隙就有 id 为 (3,10)，(10,20)，(20,正无穷) 这三个区间， 在Session_1下面执行 update account set name = 'zhuge' where id > 8 and id <18;，则其他Session没 法在这个范围所包含的所有行记录(包括间隙行记录)以及行记录所在的间隙里插入或修改任何数据，即id在 (3,20]区间都无法修改数据，注意最后那个20也是包含在内的。 

间隙锁是在可重复读隔离级别下才会生效。


## 临键锁(Next-key Locks) 
Next-Key Locks是行锁与间隙锁的组合。像上面那个例子里的这个(3,20]的整个区间可以叫做临键锁。

# 无索引行锁会升级为表锁 

锁主要是加在索引上，如果对非索引字段更新，行锁可能会变表锁

InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为 表锁

锁定某一行还可以用lock in share mode(共享锁) 和for update(排它锁)，例如：select * from test_innodb_lock where a = 2 for update; 这样其他session只能读这行数据，修改则会被阻塞，直到锁定 行的session提交

# 结论

Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更 高一下，但是在整体并发处理能力方面要远远优于MYISAM的表级锁定的。当系统并发量高的时候，Innodb 的整体性能和MYISAM相比就会有比较明显的优势了。 

但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现 不仅不能比MYISAM高，甚至可能会更差。

# 行锁分析 
通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况 

> show status like 'innodb_row_lock%'; 对各个状态量的说明如下： 

Innodb_row_lock_current_waits:

当前正在等待锁定的数量 

Innodb_row_lock_time: 

从系统启动到现在锁定总时间长度 

Innodb_row_lock_time_avg: 

每次等待所花平均时间 

Innodb_row_lock_time_max：

从系统启动到现在等待最长的一次所花时间

Innodb_row_lock_waits:

系统启动后到现在总共等待的次数 


对于这5个状态变量，比较重要的主要是： 

Innodb_row_lock_time_avg （等待平均时长）

Innodb_row_lock_waits （等待总次数） 

Innodb_row_lock_time（等待总时长） 

尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待， 然后根据分析结果着手制定优化计划。


# 查看INFORMATION_SCHEMA系统库锁相关数据表

 ‐‐ 查看事务 

 > select * from INFORMATION_SCHEMA.INNODB_TRX; 

  ‐‐ 查看锁 

 > select * from INFORMATION_SCHEMA.INNODB_LOCKS; 

 ‐‐ 查看锁等待 

 > select * from INFORMATION_SCHEMA.INNODB_LOCK_WAITS; 

 ‐‐ 释放锁，trx_mysql_thread_id可以从INNODB_TRX表里查看到 

 > kill trx_mysql_thread_id 1011 

 ‐‐ 查看锁等待详细信息  

 > show engine innodb status\G;


# 锁优化建议 

 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁 

 合理设计索引，尽量缩小锁的范围 

 尽可能减少检索条件范围，避免间隙锁 

 尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行 

 尽可能低级别事务隔离


 