---
layout:     post
title:      Java并发-1
subtitle:   Java并发系列
date:       2021-07-05
author:     CodingAndLiving
header-img: img/com01.jpg
catalog: true
tags:
    - Java并发
    - 原理
    - 底层
---
# 前言

> 在繁杂的世界，能够沉下心来，梳理下知识体系，其实是一件很放松的诗意。


# 硬件基础知识

1. 存储空间大小排序： 内存  > 三级缓存 > 二级缓存 > 一级缓存 > 寄存器

2. 读取速度 ： 反向

3. 一级缓存，从二级缓存里面读取数据；二级缓存从三级缓存读取数据；三级缓存从内存读取数据；

4. 每一次读取数据，是按照缓存行一行一行读取，并不是说需要某个变量，就只读取该变量；

5. 缓存的理论：时间局部性，空间局部性

6. 问题1： 二维数组，是按照逐行读取，还是逐列读取较好？

7. 创建线程分类（由谁负责创建）：内核线程模型、用户线程模型

8. 指令集分类：寄存器指令集、栈指令集

# 什么是JMM模型？ 
Java内存模型(Java Memory Model简称JMM)是一种抽象的概念，并不真实存在，它 描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段 和构成数组对象的元素）的访问方式。JVM运行程序的实体是线程，而每个线程创建时 JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java 内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问， 但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自 己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作 主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个 线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必 须通过主内存来完成。 

JMM不同于JVM内存区域模型 JMM与JVM内存区域的划分是不同的概念层次，更恰当说JMM描述的是一组规则，通 过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕 **原子性，有序性、可见性**展开。JMM与Java内存区域唯一相似点，都存在共享数据区域和 私有数据区域，在JMM中主内存属于共享数据区域。

1. 主内存
2. 线程私有工作内存

# 数据同步八大原子操作 
1. lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态 
2. unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后 的变量才可以被其他线程锁定 
3. read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存 中，以便随后的load动作使用 
4. load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工 作内存的变量副本中 
5. use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎 
6. assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内 存的变量 
7. store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存 中，以便随后的write的操作 
8. write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值 传送到主内存的变量中


# 原子性
原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不 会被其他线程影响。

# 可见性
可见性指的是当一个线程修改了某个共享变量 的值，其他线程是否能够马上得知这个修改的值。

# 有序性
有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，这 样的理解并没有毛病，毕竟对于单线程而言确实如此，但对于多线程环境，则可能出现乱序 现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺 序未必一致，要明白的是，在Java程序中，倘若在本线程内，所有操作都视为有序行为，如 果是多线程环境下，一个线程中观察另外一个线程，所有操作都是无序的，前半句指的是单 线程内保证串行语义执行的一致性，后半句则指指令重排现象和工作内存与主内存同步延迟 现象。

# 解决原子性问题
可以通过 synchronized和 Lock实现原子性

# 解决可见性问题
volatile关键字保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值立即 被其他的线程看到，即修改的值立即更新到主存中，当其他线程需要读取时，它会去内存中 读取新值。

synchronized和Lock也可以保证可见性，因为它们可以保证任一时刻只有一个 线程能访问共享资源，并在其释放锁之前将修改的变量刷新到内存中。

# 解决有序性问题
在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在后面讲 述volatile关键字）。

另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行 同步代码，自然就保证了有序性。

# volatile关键字有如下两个作用 
1. 保证被volatile修饰的共享变量对所有线程总数可见的，也就是当一个线程修改 了一个被volatile修饰共享变量的值，新值总是可以被其他线程立即得知。 
2. 禁止指令重排序优化。

### volatile无法保证原子性
在并发场景下，i变量的任何改变都会立马反应到其他线程中，但是如此存在多条线程 同时调用increase()方法的话，就会出现线程安全问题，毕竟i++;操作并不具备原子性，该 操作是先读取值，然后写回一个新值，相当于原来的值加上1，分两步完成，如果第二个线 程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程 一起看到同一个值，并执行相同值的加1操作，这也就造成了线程安全失败，

因此对于 increase方法必须使用synchronized修饰，以便保证线程安全，需要注意的是一旦使用synchronized修饰方法后，由于synchronized本身也具备与volatile相同的特性，即可见 性，因此在这样种情况下就完全可以省去volatile修饰变量。

### volatile是如 何实现禁止指令重排优化的。内存屏障(Memory Barrier）
这里不过多介绍内存屏障

