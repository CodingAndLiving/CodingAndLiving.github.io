---
layout:     post
title:      jvm系列-1
subtitle:   学习jvm，从拒绝面试应付套路开始
date:       2021-02-05
author:     CodingAndLiving
header-img: img/com01.jpg
catalog: true
tags:
    - jvm
    - 原理
    - 底层
---
# 前言

> **本文**主要讲解jvm


 
# JDK、JRE、JVM三者关系。
1. JDK包含JRE，JRE包含JVM。
2. JRE = JVM + 各种jar包，例如lang and util,logging,Collections,InputOutput,Networking,Swing,AWT, java2d等。
3. JDK = JRE + Java Language + Tools(例如java命令，javac命令，javap命令，JVisualVM命令等)

这里有种说法，服务器上只需要部署jre，无需部署jdk。是否正确？

从运行程序角度，是可以运行的，但是缺乏了各种tools的使用，例如javap等命令无法执行。

# JVM的作用
1. 先看一个流程：
    1. java文件被编译为class文件。
    2. class文件被jvm执行
	3. 底层平台分别是window系统、linux系统。

2. 屏蔽了不同操作系统底层的区别。

# JVM组成部分
1. 装载子系统：负责class文件的装载。
2. 运行时数据区。
    1. 堆
    2. 线程栈
    3. 本地方法栈
    4. 方法区
    5. 程序计数器
3. 字节码执行器：负责将字节码转化为汇编机器码执行。

# 运行时数据区说明
1. 以下面java代码示例进行讲解：
```

package com.example.demo;

public class JavaTest {
    private static final int num=5;
    private static String name = new String();
    
    public int cal(){
        int a=1;
        int b=2;
        int c= (a+b)*10;
        return c;
    }

    public static void main(String[] args){
        JavaTest ts = new JavaTest();
        ts.cal();
        System.out.println("hello JVM");
    }
}

```

2. 启动main方法之后，会产生一个main线程，会从线程栈里面分配一部分空间提供给该线程，所以这里可以知道线程栈是私有的。
3. 线程，先执行main方法，将main方法作为栈帧压栈，后执行JavaTest对象的cal方法，后面压栈。栈的特点：先进后出，负责代码方法的调用顺序。
4. 每一个栈帧分别含有以下组成部分：
    1. 局部变量表
    2. 操作数栈
    3. 动态链接：将符号引用转变为直接引用
    4. 方法出口：方法执行完毕后，返回的直接地址，例如cal方法执行完毕后，返回下一行代码的位置是System输出语句。

5. 讲解局部变量表和操作数栈。

上述java代码编译后的class文件可以看到内容是4位一组的数字串，例如0123 0200 之类的感觉。该种字节码不便于阅读，可以采取javap命令转变为易于阅读的格式。例如下：
```

public int cal();
  Code:
  	0: iconst_1
    1: istroe_1
	2: iconst_2
	3: istroe_2
	4: iload_1
	5: iload_2
	6: iadd
	7: bipush 10
	9: imul
    10:istore_3
	11:iload_3
	12: ireturn


```

上面是随手打的代码，如果有出入，请忽略。

    1. 上述命令具体可以查看jvm指令文档，这里简单说明，用于描述操作数栈和局部变量表。
    2. 上面示例每个指令前面都有序号，这个序号，就是存储在jvm运行时数据区的程序计数器；类似于线程栈，其中每一个线程都会从程序计数器里面获得部分空间，作为线程私有。为什么需要程序计数器，是当多线程执行时候，如果线程挂起，后续被重新调度执行，需要程序计数器里面找到重新执行的代码位置。
	ps：程序计数器的存储内容的更新，都是由字节码执行器进行执行的。
	ps1: 同理，每一个线程栈都会具有本地方法栈的一部分空间。本地方法是指，java利用jni调用c方法
    3. 第一条指令：从局部变量表的第一个位置创建了变量1；这里局部变量表可以理解为数组结构，第0位变量是存放this对象。
    4. 第二条指令： 将1往操作数栈，进行压栈；操作数栈是数据进行计算的临时空间。
	5. 第三条指令：从局部变量表第二个位置创建了变量2；
	6. 第四条指令： 将数2往操作数栈进行压栈。
	7. 将操作数栈的1和2出栈，进行相加动作，结果入栈。将10往操作数栈进行压栈，两者出栈，进行乘法运算，结果如栈。

6. 局部变量的表的扩展：和cal栈帧不同，其中main栈帧，的局部变量表ts是实例化一个对象，所以这里ts的局部变量是指向堆的一个引用。扩展一下，堆和线程栈的关系是啥？线程栈的局部变量表会存在对于堆的引用

7. 方法区：会存放类信息、常量、静态变量。例如上述java代码示例就存在一个常量，一个静态变量。同理，静态变量也是存放了一个指向堆的引用

8. 到这里为止，可以知道，堆和方法区是线程共有的，其余线程栈、本地方法栈、程序计数器，则是线程私有的。

9. 堆的区域内部划分：
    1. 年轻代和年老代。
    2. 年轻代，划分为E区和S区；S区分为S0和S1
    3. 刚开始实例化出来的对象都位于E区，后面在进行ygc的时候，会在S0和S1之间进行轮换；若是进行了达到一定年龄，则会到达年老代；这里涉及可达性分析算法。算法思路是 从 gc roots 节点出发，找到有引用的对象，和没有引用的对象，从而将没有引用的对象回收。
	4. gc roots 包含线程栈的局部变量、方法区的静态变量、本地方法栈的变量。

ps ： java实例出来的一个对象，除去了对象实例信息，还包含对象头部等信息。

10. 以下面方法说明，由于是while true 循环，线程一直执行，局部变量表会持有集合的引用，集合一直实例化对象，导致对象一直不会被释放，直接oom。
```


    public static void main(String[] args)throws Exception{
        List<JavaTest> array = new ArrayList<>();
        while (true){
            array.add(new JavaTest());
            Thread.sleep(10000);
        }
                
    }
```

# 模拟一个内存调优案例。
1. 一个jvm参数：方法区512M，线程栈都是1M，老年代2G，E区800M，S0和S1分别占用100M
2. 假设业务是下单系统。每秒钟产生若干笔订单，一共60M大小。
3. 由于刚开始实例化的对象都放在E区，需要全占满E区，大概需要12或者13左右的的1秒，就会发生一次gc；这时候，假设E区存在13个60M大小的空间，由于订单下单完毕后，线程栈就会结束，E区的对象就会被标示为可回收对象。但是加上考虑，发生gc时候，可能存在个别一两个线程还没执行完毕，被挂起了，所以假设存在一个60M大小的空间分配去了S0区域，但是由于60M超过了S0区域大小的一半，会直接派到老年代。
4. 相当于每13秒，会让老年人增加内存占用60M，大概需要多长时间，占满老年代？7分钟左右。所以每7分钟左右，就会发生一次fgc，系统给人感觉就是很卡顿。

ps：jvm调优目的是降低成本的同时使得程序更好运行。换个直接说法，就是降低gc的次数，因为gc的时候，会让用户线程停止。
ps：为什么gc会让用户线程停止，这是由于gc需要进行可达性分析，如果用户线程继续执行，那么可达性分析结果不准。无法分析。



# 操作系统内存模型和jvm运行时数据区的关系
1. 操作系统内存模型：
    1. 代码块
    2. 数据区
    3. 栈
    4. 堆
2. 其中只有堆可以让程序员进行操作，其余三者都是os说了算。例如c语言可以利用api进行申请内存
3. 堆下面就包含了jvm的内存模型。


ps：在jdk7的时候，jvm运行时数据区的方法区是挂在 jvm运行时数据区的堆下面的。
但是后面独立了出来，如本文描述一样，挂在了os系统的堆下面。


# 方法区
1. 以上面的java代码示例，
2. 方法区会存放klass对象，然后该对象里面会存在方法对象集合，该集合里面例如含有main方法、cal方法。
3. 之前说到线程栈里面栈帧会有一个动态链接，其实这个就是对应方法的地址，例如main方法的栈帧，里面的动态链接就是main方法的地址。
4. 由此可以知道，线程栈里面是存在指向方法区这么一个特点。
5. 之前说过，方法区存在对于静态变量指向堆，这个是jdk1.7之前的设计；jdk8之后，将静态变量属性放到了堆里面，例如class对象。

# 对象对于方法区的指向
1. 上面说到堆里面的一个对象除去了对象实例数据，还包含对象头，例如，含有类型指针，用于指向方法区，表示对象是什么类型。
2. 所以，堆区也存在一个指向方法区的箭头。



# 堆区
1. 上面说了堆的划分，例如年轻代，年老代。但这个只是理论层面的设计。
2. 关于内存分配角度来看了，
    1. 首先内存分配策略有三种：指针碰撞、空间列表、线程私有堆（TLAB）
	2. 其中据说空间列表只是一种方案，但是具体的源码只使用其余两者。后面再来关注下源码
3. 名字看起来很唬人，其实理解不难：
    1. 之前说到，jvm运行时数据区的堆，其实是从操作系统里面的堆中获取了一部分空间。
	2. 我们接着，将jvm运行时数据区的堆，划分三等份，其中年轻代占用了一份，年老代占用了两份；
	3. 接着，年轻代里面划分十等份，S0和S1各自占用一份，剩余8份全给了Eden区域。

4. 在这个基础上，如果采取空间列表策略，如下：
	1. 首先维护了三条列表，这里先不规定数据结构，可以是数组，或者链表。
	2. idle 空闲列表、 used 已用列表、 available 可用列表。
	3. 类比设计里面的E区、S0、S1区域。这里的可用列表，就是E区，已用列表是E区剩余部分，空闲列表相当于S0或者S1区域。说白了，空闲列表就是用来进行交换的。
	4. 假设，一开始jvm从操作系统获得了一部分堆空间，那么这时候，可用列表，假设长度为10个单位，已用列表长度为0；
	5. 接着，线程申请了一个单位的堆，那么可用列表减少了一个单位，已用列表增加了一个单位。
	6. 由于用完后，内存会被回收，但是由于回收回来的内存是一块块的，不再是刚开始时候的一整块。例如，一开始是一块10个单位的，回收回来后，可能是1块5，1块2，一块3；这样子就会产生内存碎片化问题。

5. 线程私有堆
	1. 相当于将堆区域划分两大块，一个是线程共有区，一个是线程私有区。
	2. 好处是，当一个线程实例化100个对象时候，需要申请100个内存区域，如果不存在线程私有堆，那么为了解决多线程优先顺序问题，需要加解锁100次，如果有了线程私有堆，那么只需要在首次申请线程私有堆的时候，加解锁。减少了锁的性能开销。

6. 指针碰撞
	1. 例如Eden区域，首尾分别有一个指针，两个指针的间隔，表示内存区域大小，例如10个单位。
	2. 假如要分配6个单位的内存，那么与两个指针间隔比较，如果小于间隔，那么说明有充足的内存空间，可以分配。
	3. 然后，基于首部指针位置，加上6个单位的大小，增加了新的指针new_po，这时候，将原来的首部指针返回出去，表示内存的起始地址，接着将首部指针挪到new_po的位置。


# 方法区、永久代、元空间三者的关系
1. 方法区是jvm的规范。
2. 永久代、元空间分别是具体实现；
3. jdk7及其之前，实现是永久代，jdk8开始是元空间；
4. 元空间+ codecache + 其余组成部分 = 方法区
5. 永久代的坏处：
	1. 堆的大小是有限的，永久代占用了堆的空间，影响了对象的存储；
	2. 永久代的oom，也会导致整一个堆的oom；
	3. 由于堆的大小是有限的，导致永久代存储的类信息有限；
6. 元空间也存在一定的弊端，例如内存碎片；
7. 元空间存在内存碎片的理解，也是不难，如下：
	1. 首先知道，类加载器分别有系统加载器、扩展加载器、应用加载器，还有开发者自定义的加载器；
	2. 其实每一个类加载器都是分别占用不同的存储空间的，如果定义了若干个开发者自定义的类加载器，那么每一个自定义的类加载器都占用各自的内存空间，；当然，由于还有双亲委托加载机制，自定义类加载器上面还有应用类加载器，应用类加载器也是自己占用一份存储空间。
	3. 以自定义类加载器为例，占用了一份存储空间类似于上面描述的空间列表例子的原因，会导致内存碎片；

# 线程栈和栈帧
1. 一个线程就是一个线程栈；
2. 每发生一次方法调用，会产生一个栈帧；
3. 局部变量表和操作数栈的大小是在编译期间就确定了的，所以class文件里面其实是包含了局部变量表和操作数栈的空间大小；
4. 局部变量的作用域是如何确定的？
	1. 也是在编译时候就明确了。
	2. 含有两个信息，起始位置、长度；这两者实现了局部变量的作用域；
	3. 当长度为0的局部变量，是不会记录在局部变量表里面的；
	4. 这个也可以idea安装jclassLIb插件来观看；


# 局部变量表的第一个变量是this
1. 以下面代码示例说明


```

package com.example.test;

public class JTest {
    public void add(){}

    public static void main(String[] args)throws Exception{
        JTest a = new JTest();

    }
}

```


2. 利用jclasslib可以查看到jvm指令码如下
```

0 new #2 <com/example/test/JTest>
	在堆内分配内存，设置mark word 、类型指针等；
	然后将对象的物理地址，压入操作数栈
3 dup
	复制栈顶元素，也就是相当于物理对象的内存地址；
	然后，再次压入操作数栈。
	这里有个疑问，上述步骤，相当于操作数栈存在两个相同的物理地址，为啥需要两个？这里先解释，一个给this赋值，一个给局部变量JTest a赋值；
4 invokespecial #3 <com/example/test/JTest.<init>>
	
7 astore_1
8 return

```