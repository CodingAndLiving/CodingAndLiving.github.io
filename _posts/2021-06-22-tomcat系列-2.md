---
layout:     post
title:      tomcat系列-2
subtitle:   tomcat源码
date:       2021-06-22
author:     CodingAndLiving
header-img: img/com01.jpg
catalog: true
tags:
    - tomcat
    - 源码
    - 底层
---
# 前言

> 在繁杂的世界，能够沉下心来，梳理下知识体系，其实是一件很放松的诗意。

其实之前也写过一篇博客，介绍了tomcat的组件，接下来这个新系列，打算从源码角度描述下。希望本人不懒惰，能坚持写下去。

# Tomcat 启动流程

老规矩，从下面这个入口开始看起，
org.apache.catalina.startup.Bootstrap#start

接着看到下面方法

```
  public void start() {

        if (getServer() == null) {
            load();
        }

        if (getServer() == null) {
            log.fatal("Cannot start server. Server instance is not configured.");
            return;
        }

        long t1 = System.nanoTime();

        // Start the new server
        try {
            getServer().start();
        } catch (LifecycleException e) {
            log.fatal(sm.getString("catalina.serverStartFail"), e);
            try {
                getServer().destroy();
            } catch (LifecycleException e1) {
                log.debug("destroy() failed for failed Server ", e1);
            }
            return;
        }

        long t2 = System.nanoTime();
        if(log.isInfoEnabled()) {
            log.info("Server startup in " + ((t2 - t1) / 1000000) + " ms");
        }

        // Register shutdown hook
        if (useShutdownHook) {
            if (shutdownHook == null) {
                shutdownHook = new CatalinaShutdownHook();
            }
            Runtime.getRuntime().addShutdownHook(shutdownHook);

            // If JULI is being used, disable JULI's shutdown hook since
            // shutdown hooks run in parallel and log messages may be lost
            // if JULI's hook completes before the CatalinaShutdownHook()
            LogManager logManager = LogManager.getLogManager();
            if (logManager instanceof ClassLoaderLogManager) {
                ((ClassLoaderLogManager) logManager).setUseShutdownHook(
                        false);
            }
        }

        if (await) {
            await();
            stop();
        }
    }

```


1. 首先来看看，await方法里面的一个小动作，

 ```
 boolean match = command.toString().equals(shutdown);
                if (match) {
                    log.info(sm.getString("standardServer.shutdownViaPort"));
                    break;
                }
```

这是指我们配置文件里面


`<Server port="8005" shutdown="SHUTDOWN">`

这里配置的shutdown的值，其实可以实现关机效果，所以一般部署时候，处于安全考虑，会给该值进行修改。



2. 下面看看server的start方法

org.apache.catalina.core.StandardServer#startInternal

接着看看Service的start方法，这里面就丰富了
```

 @Override
    protected void startInternal() throws LifecycleException {

        if(log.isInfoEnabled())
            log.info(sm.getString("standardService.start.name", this.name));
        setState(LifecycleState.STARTING);

        // Start our defined Container first
        if (engine != null) {
            synchronized (engine) {
                engine.start();
            }
        }

        synchronized (executors) {
            for (Executor executor: executors) {
                executor.start();
            }
        }

        mapperListener.start();

        // Start our defined Connectors second
        synchronized (connectorsLock) {
            for (Connector connector: connectors) {
                try {
                    // If it has already failed, don't try and start it
                    if (connector.getState() != LifecycleState.FAILED) {
                        connector.start();
                    }
                } catch (Exception e) {
                    log.error(sm.getString(
                            "standardService.connector.startFailed",
                            connector), e);
                }
            }
        }
    }


```

	1. 先来看看engine的启动方法，这个是继承父类的  org.apache.catalina.core.ContainerBase#startInternal

其实包括背后的容器，例如host，context等，start的方法也是很类似。


好了，启动流程，暂告一段落，下面看看热加载热部署，以及tomcat处理请求专题

# Tomcat 热部署流程

# Tomcat 处理请求专题

上次说到了Connector里面含有组件NioEndpoint,我们就以这个开始。

1. NioEndPoint 里面含有组件Acceptor，Poller，Executor。
2. Acceptor此线程接受socket连接，然后直接通过setSocketOptions(socket)方法直接添加到Poller的events队列中。
3. Poller线程，处理socket的读写事件，通过hasEvents = events()把events队列中的连接注册到当前线程的selector多路复用器上，并监测当前连接的可读事件。一旦客户端有请求数据selector.selectedKeys().iterator(),获取所有有请求的连接进行数据处理。通过processSocket方法把连接请求传递给工作线程进行处理。也就是 executor.execute(sc).
4. 每一个executor线程，真正进行数据的读取会写以及业务处理。拿到上一步分装好的NioEndpoint的内部类SocketProcessor,工作线程会执行SocketProcessor的run方法.
5. 进而调用 getHandler().process(socketWrapper,SocketEvent.OPEN_READ)
6. ConnectionHandler.process(SocketWrapperBase < S > wrapper, SocketEvent status).
ConnectionHandler是Http11NioProtocol的顶层父类AbstractProtocol的内部类，在Http11NioProtocol的实例化过程的父类的构造方法，创建了ConnectionHandler的实例，并且赋值给了NioEndpoint。

此方法会将socket和Http11Processor放入map进行关联。

7. 由于此调用链过长，不再逐一列举，仅仅列举其中重要方法。
Http11Processor.service(SocketWrapperBase< ? >)

该方法会进行http协议的解析：

请求行解析：inputBuffer.parseRequestLine(keptAlive)

请求头解析：inputBuffer.parseHeaders()


8. CoyoteAdaper.service

此方法会匹配出当前请求的host,context,wrapper
通过postParseRequest进行匹配

connector.getService().getContainer().getPipeline.getFirst().invoke()

这里是执行tomcat容器的管道线模型

管道线执行结束，也就是业务处理完毕，进行相应数据的会写，service方法的最后会调用response.finishResponse方法进行数据回写。如果socket连接不可写，把当前socket注册到多路复用器（Block Poller线程），监测可写事件，然后加锁等待，直到通道可写，才进行解锁。


9. 最后回顾下上面说的容器的管道线模型调用过程。

StandardWrapperValva.invoke()

这个是容器最后的wrapper了，这个管道线后面会处理filter和service调用。

依次如下：

ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain()

filterChain.doFilter

doFilter为递归调用，业务Filter的doFilter方法的最后一定要调用filterChain.doFilter，不然调用链就会断掉，无法执行后续的filter和service。


internalDoFilter的最后会调用servlet的service方法。


