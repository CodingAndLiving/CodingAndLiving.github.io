---
layout:     post
title:      tomcat系列-2
subtitle:   tomcat源码
date:       2021-06-22
author:     CodingAndLiving
header-img: img/com01.jpg
catalog: true
tags:
    - tomcat
    - 源码
    - 底层
---
# 前言

> 在繁杂的世界，能够沉下心来，梳理下知识体系，其实是一件很放松的诗意。

其实之前也写过一篇博客，介绍了tomcat的组件，接下来这个新系列，打算从源码角度描述下。希望本人不懒惰，能坚持写下去。

# Tomcat 启动流程

老规矩，从下面这个入口开始看起，
org.apache.catalina.startup.Bootstrap#start

接着看到下面方法

```
  public void start() {

        if (getServer() == null) {
            load();
        }

        if (getServer() == null) {
            log.fatal("Cannot start server. Server instance is not configured.");
            return;
        }

        long t1 = System.nanoTime();

        // Start the new server
        try {
            getServer().start();
        } catch (LifecycleException e) {
            log.fatal(sm.getString("catalina.serverStartFail"), e);
            try {
                getServer().destroy();
            } catch (LifecycleException e1) {
                log.debug("destroy() failed for failed Server ", e1);
            }
            return;
        }

        long t2 = System.nanoTime();
        if(log.isInfoEnabled()) {
            log.info("Server startup in " + ((t2 - t1) / 1000000) + " ms");
        }

        // Register shutdown hook
        if (useShutdownHook) {
            if (shutdownHook == null) {
                shutdownHook = new CatalinaShutdownHook();
            }
            Runtime.getRuntime().addShutdownHook(shutdownHook);

            // If JULI is being used, disable JULI's shutdown hook since
            // shutdown hooks run in parallel and log messages may be lost
            // if JULI's hook completes before the CatalinaShutdownHook()
            LogManager logManager = LogManager.getLogManager();
            if (logManager instanceof ClassLoaderLogManager) {
                ((ClassLoaderLogManager) logManager).setUseShutdownHook(
                        false);
            }
        }

        if (await) {
            await();
            stop();
        }
    }

```


1. 首先来看看，await方法里面的一个小动作，

 ```
 boolean match = command.toString().equals(shutdown);
                if (match) {
                    log.info(sm.getString("standardServer.shutdownViaPort"));
                    break;
                }
```

这是指我们配置文件里面


`<Server port="8005" shutdown="SHUTDOWN">`

这里配置的shutdown的值，其实可以实现关机效果，所以一般部署时候，处于安全考虑，会给该值进行修改。



2. 下面看看server的start方法

org.apache.catalina.core.StandardServer#startInternal

接着看看Service的start方法，这里面就丰富了
```

 @Override
    protected void startInternal() throws LifecycleException {

        if(log.isInfoEnabled())
            log.info(sm.getString("standardService.start.name", this.name));
        setState(LifecycleState.STARTING);

        // Start our defined Container first
        if (engine != null) {
            synchronized (engine) {
                engine.start();
            }
        }

        synchronized (executors) {
            for (Executor executor: executors) {
                executor.start();
            }
        }

        mapperListener.start();

        // Start our defined Connectors second
        synchronized (connectorsLock) {
            for (Connector connector: connectors) {
                try {
                    // If it has already failed, don't try and start it
                    if (connector.getState() != LifecycleState.FAILED) {
                        connector.start();
                    }
                } catch (Exception e) {
                    log.error(sm.getString(
                            "standardService.connector.startFailed",
                            connector), e);
                }
            }
        }
    }


```

	1. 先来看看engine的启动方法，这个是继承父类的  org.apache.catalina.core.ContainerBase#startInternal

其实包括背后的容器，例如host，context等，start的方法也是很类似。


好了，启动流程，暂告一段落，下面看看热加载热部署，以及tomcat处理请求专题

# Tomcat 热部署流程

要在运行的过程中升级 Web 应用，如果你不想重启系统，实现的方式有两种： 热加载和热部署。 

1. 热加载的实现方式是 Web 容器启动一个后台线程，定期检测类文件 的变化，如果有变化，就重新加载类，在这个过程中不会清空 Session ， 一般用在开发环境。 
2. 热部署原理类似，也是由后台线程定时检测 Web 应用的变化，但它 会重新加载整个 Web 应用。这种方式会清空 Session，比热加载更加干 净、彻底，一般用在生产环境。

Tomcat 就是通过开启后台线程实现：

在engine的启动流程里面，就会启动下面这个后台线程。

```

    protected void threadStart() {

        if (thread != null)
            return;
        if (backgroundProcessorDelay <= 0)
            return;

        threadDone = false;
        String threadName = "ContainerBackgroundProcessor[" + toString() + "]";
        thread = new Thread(new ContainerBackgroundProcessor(), threadName);
        thread.setDaemon(true);
        thread.start();

    }
```

任务类 ContainerBackgroundProcessor，它是一个 Runnable，同时也是 ContainerBase 的内部类，ContainerBase 是所有容器组件的基类

```

    protected class ContainerBackgroundProcessor implements Runnable {

        @Override
        public void run() {
            Throwable t = null;
            String unexpectedDeathMessage = sm.getString(
                    "containerBase.backgroundProcess.unexpectedThreadDeath",
                    Thread.currentThread().getName());
            try {
                while (!threadDone) {
                    try {
                        Thread.sleep(backgroundProcessorDelay * 1000L);
                    } catch (InterruptedException e) {
                        // Ignore
                    }
                    if (!threadDone) {
                        processChildren(ContainerBase.this);
                    }
                }
            } catch (RuntimeException|Error e) {
                t = e;
                throw e;
            } finally {
                if (!threadDone) {
                    log.error(unexpectedDeathMessage, t);
                }
            }
        }

        protected void processChildren(Container container) {
            ClassLoader originalClassLoader = null;

            try {
                if (container instanceof Context) {
                    Loader loader = ((Context) container).getLoader();
                    // Loader will be null for FailedContext instances
                    if (loader == null) {
                        return;
                    }

                    // Ensure background processing for Contexts and Wrappers
                    // is performed under the web app's class loader
                    originalClassLoader = ((Context) container).bind(false, null);
                }
                //1. 调用当前容器的backgroundProcess方法。
                container.backgroundProcess();

                //2. 遍历所有的子容器，递归调用processChildren，
                // 这样当前容器的子孙都会被处理
                Container[] children = container.findChildren();
                for (Container child : children) {
                    //这里请你注意，容器基类有个变量叫做backgroundProcessorDelay，
                    // 如果大于0，表明子容器有自己的后台线程，无需父容器来调用它的processChildren方 法。

                    if (child.getBackgroundProcessorDelay() <= 0) {
                        processChildren(child);
                    }
                }
            } catch (Throwable t) {
                ExceptionUtils.handleThrowable(t);
                log.error("Exception invoking periodic operation: ", t);
            } finally {
                if (container instanceof Context) {
                    ((Context) container).unbind(false, originalClassLoader);
               }
            }
        }
    }


```

```

  @Override
    public void backgroundProcess() {

        if (!getState().isAvailable())
            return;

        Cluster cluster = getClusterInternal();
        if (cluster != null) {
            try {
                //1.执行容器中Cluster组件的周期性任务
                cluster.backgroundProcess();
            } catch (Exception e) {
                log.warn(sm.getString("containerBase.backgroundProcess.cluster",
                        cluster), e);
            }
        }
        //2.执行容器中Realm组件的周期性任务
        Realm realm = getRealmInternal();
        if (realm != null) {
            try {
                realm.backgroundProcess();
            } catch (Exception e) {
                log.warn(sm.getString("containerBase.backgroundProcess.realm", realm), e);
            }
        }
        //3.执行容器中Valve组件的周期性任务
        Valve current = pipeline.getFirst();
        while (current != null) {
            try {
                current.backgroundProcess();
            } catch (Exception e) {
                log.warn(sm.getString("containerBase.backgroundProcess.valve", current), e);
            }
            current = current.getNext();
        }
        //4. 触发容器的"周期事件"，Host容器的监听器HostConfig就靠它来调用
        fireLifecycleEvent(Lifecycle.PERIODIC_EVENT, null);
    }

```
从上面的代码可以看到，不仅每个容器可以有周期性任务，每个容器中的其他通 用组件，比如跟集群管理有关的 Cluster 组件、跟安全管理有关的 Realm 组件 都可以有自己的周期性任务。


## Tomcat 热加载 

有了 ContainerBase 的周期性任务处理“框架”，作为具体容器子类，只需要 实现自己的周期性任务就行。而 Tomcat 的热加载，就是在 Context 容器中实 现的。Context 容器的 backgroundProcess 方法是这样实现的：

org.apache.catalina.core.StandardContext#backgroundProcess

```
  @Override
    public void backgroundProcess() {

        if (!getState().isAvailable())
            return;
        //WebappLoader周期性的检查WEB‐INF/classes和WEB‐INF/lib目录下的类文件
        Loader loader = getLoader();
        if (loader != null) {
            try {
                loader.backgroundProcess();
            } catch (Exception e) {
                log.warn(sm.getString(
                        "standardContext.backgroundProcess.loader", loader), e);
            }
        }
        //Session管理器周期性的检查是否有过期的Session
        Manager manager = getManager();
        if (manager != null) {
            try {
                manager.backgroundProcess();
            } catch (Exception e) {
                log.warn(sm.getString(
                        "standardContext.backgroundProcess.manager", manager),
                        e);
            }
        }
        //周期性的检查静态资源是否有变化
        WebResourceRoot resources = getResources();
        if (resources != null) {
            try {
                resources.backgroundProcess();
            } catch (Exception e) {
                log.warn(sm.getString(
                        "standardContext.backgroundProcess.resources",
                        resources), e);
            }
        }
        InstanceManager instanceManager = getInstanceManager();
        if (instanceManager instanceof DefaultInstanceManager) {
            try {
                ((DefaultInstanceManager)instanceManager).backgroundProcess();
            } catch (Exception e) {
                log.warn(sm.getString(
                        "standardContext.backgroundProcess.instanceManager",
                        resources), e);
            }
        }
        //调用父类ContainerBase的backgroundProcess方法
        super.backgroundProcess();
    }

```

从上面的代码我们看到 Context 容器通过 WebappLoader 来检查类文件是否 有更新，通过 Session 管理器来检查是否有 Session 过期，并且通过资源管理 器来检查静态资源是否有更新，最后还调用了父类 ContainerBase 的 backgroundProcess 方法。


WebappLoader 是如何实现热加载的，它主要是调用了 Context 容器的 reload 方法，而 Context 的 reload 方法比较复杂，总结起来，主要完成了下 面这些任务： 

1. 停止和销毁 Context 容器及其所有子容器，子容器其实就是 Wrapper，也就是说 Wrapper 里面 Servlet 实例也被销毁了。 

2. 停止和销毁 Context 容器关联的 Listener 和 Filter。 

3. 停止和销毁 Context 下的 Pipeline 和各种 Valve。 

4. 停止和销毁 Context 的类加载器，以及类加载器加载的类文件资源。 

5. 启动 Context 容器，在这个过程中会重新创建前面四步被销毁的资源


可以看看下面方法：

```
 @Override
    public void backgroundProcess() {
        if (reloadable && modified()) {
            try {
                Thread.currentThread().setContextClassLoader
                    (WebappLoader.class.getClassLoader());
                if (context != null) {
                    context.reload();
                }
            } finally {
                if (context != null && context.getLoader() != null) {
                    Thread.currentThread().setContextClassLoader
                        (context.getLoader().getClassLoader());
                }
            }
        }
    }
```

顺带看下，modified是如何实现的

```
 public boolean modified() {

        if (log.isDebugEnabled())
            log.debug("modified()");

        for (Entry<String,ResourceEntry> entry : resourceEntries.entrySet()) {
            long cachedLastModified = entry.getValue().lastModified;
            long lastModified = resources.getClassLoaderResource(
                    entry.getKey()).getLastModified();
            if (lastModified != cachedLastModified) {
                if( log.isDebugEnabled() )
                    log.debug(sm.getString("webappClassLoader.resourceModified",
                            entry.getKey(),
                            new Date(cachedLastModified),
                            new Date(lastModified)));
                return true;
            }
        }

        // Check if JARs have been added or removed
        WebResource[] jars = resources.listResources("/WEB-INF/lib");
        // Filter out non-JAR resources

        int jarCount = 0;
        for (WebResource jar : jars) {
            if (jar.getName().endsWith(".jar") && jar.isFile() && jar.canRead()) {
                jarCount++;
                Long recordedLastModified = jarModificationTimes.get(jar.getName());
                if (recordedLastModified == null) {
                    // Jar has been added
                    log.info(sm.getString("webappClassLoader.jarsAdded",
                            resources.getContext().getName()));
                    return true;
                }
                if (recordedLastModified.longValue() != jar.getLastModified()) {
                    // Jar has been changed
                    log.info(sm.getString("webappClassLoader.jarsModified",
                            resources.getContext().getName()));
                    return true;
                }
            }
        }

        if (jarCount < jarModificationTimes.size()){
            log.info(sm.getString("webappClassLoader.jarsRemoved",
                    resources.getContext().getName()));
            return true;
        }


        // No classes have been modified
        return false;
    }

```

根据上面代码可以知道，如果增加了新文件，能不能识别到，显然不行。


在这个过程中，类加载器发挥着关键作用。一个Context容器对应一个类加载器，
类加载器在销毁的过程中会把它加载的所有类也全部销毁。Context 容器在 启动过程中，会创建一个新的类加载器来加载新的类文件。 

在 Context 的 reload 方法里，并没有调用 Session 管理器的 destroy 方法， 也就是说这个 Context 关联的 Session 是没有销毁的。你还需要注意的是， Tomcat 的热加载默认是关闭的，你需要在 conf 目录下的 server.xml 文件中设 置 reloadable 参数来开启这个功能，

## Tomcat 热部署 

热部署跟热加载的本质区别是，热部署会重新部署 Web 应用，原来的 Context 对象会整个被销毁掉，因此这个 Context 所关联的一切资源都会被销毁，包括 Session。

那么Tomcat热部署又是由哪个容器来实现的呢？应该不是由Context，因为热部署过程中Context容器被销毁了，那么这个重担就落在 Host 身上了，因 为它是 Context 的父容器。 跟 Context 不一样，Host 容器并没有在 backgroundProcess 方法中实现周期 性检测的任务，而是通过监听器HostConfig来实现的，HostConfig就是前面提到的“周期事件”的监听器，那“周期事件”达到时，HostConfig 会做什么 事呢？

来看下面方法 org.apache.catalina.startup.HostConfig#lifecycleEvent

```
      @Override
    public void lifecycleEvent(LifecycleEvent event) {

        // Identify the host we are associated with
        try {
            host = (Host) event.getLifecycle();
            if (host instanceof StandardHost) {
                setCopyXML(((StandardHost) host).isCopyXML());
                setDeployXML(((StandardHost) host).isDeployXML());
                setUnpackWARs(((StandardHost) host).isUnpackWARs());
                setContextClass(((StandardHost) host).getContextClass());
            }
        } catch (ClassCastException e) {
            log.error(sm.getString("hostConfig.cce", event.getLifecycle()), e);
            return;
        }

        // Process the event that has occurred
        if (event.getType().equals(Lifecycle.PERIODIC_EVENT)) {
            check();
        } else if (event.getType().equals(Lifecycle.BEFORE_START_EVENT)) {
            beforeStart();
        } else if (event.getType().equals(Lifecycle.START_EVENT)) {
            start();
        } else if (event.getType().equals(Lifecycle.STOP_EVENT)) {
            stop();
        }
    }

```
主要调用了check方法

```
  /**
     * Check status of all webapps.
     */
    protected void check() {

        if (host.getAutoDeploy()) {
            // 检查这个Host下所有已经部署的Web应用
            // Check for resources modification to trigger redeployment
            DeployedApplication[] apps = deployed.values().toArray(new DeployedApplication[0]);
            for (DeployedApplication app : apps) {
                if (tryAddServiced(app.name)) {
                    try {
                        //检查Web应用目录是否有变化
                        checkResources(app, false);
                    } finally {
                        removeServiced(app.name);
                    }
                }
            }

            // Check for old versions of applications that can now be undeployed
            if (host.getUndeployOldVersions()) {
                checkUndeploy();
            }

            // Hotdeploy applications
            //执行部署
            deployApps();
        }
    }

```
其实 HostConfig 会检查 webapps 目录下的所有 Web 应用：

1. 如果原来 Web 应用目录被删掉了，就把相应 Context 容器整个销毁 掉。

2. 是否有新的 Web 应用目录放进来了，或者有新的 WAR 包放进来 了，就部署相应的 Web 应用。


## Tomcat 的类加载器 

Tomcat 的自定义类加载器WebAppClassLoader打破了双亲委托机制，它首先自己尝试去加载某个类，如果找不到再代理给父类加载器，其目的是优先加载 Web 应用自己定义的类。具体实现就是重写 ClassLoader 的两个方法： findClass 和 loadClass。


> 之前的文章介绍过加载过程的tomcat的类加载器，下面讲述关于tomcat加载部署webapp的类加载器。

先来看看 org.apache.catalina.loader.WebappClassLoaderBase#findClass

```
   @Override
    public Class<?> findClass(String name) throws ClassNotFoundException {

        if (log.isDebugEnabled())
            log.debug("    findClass(" + name + ")");

        checkStateForClassLoading(name);

        // (1) Permission to define this class when using a SecurityManager
        if (securityManager != null) {
            int i = name.lastIndexOf('.');
            if (i >= 0) {
                try {
                    if (log.isTraceEnabled())
                        log.trace("      securityManager.checkPackageDefinition");
                    securityManager.checkPackageDefinition(name.substring(0,i));
                } catch (Exception se) {
                    if (log.isTraceEnabled())
                        log.trace("      -->Exception-->ClassNotFoundException", se);
                    throw new ClassNotFoundException(name, se);
                }
            }
        }

        // Ask our superclass to locate this class, if possible
        // (throws ClassNotFoundException if it is not found)
        Class<?> clazz = null;
        try {
            if (log.isTraceEnabled())
                log.trace("      findClassInternal(" + name + ")");
            try {
                if (securityManager != null) {
                    PrivilegedAction<Class<?>> dp =
                        new PrivilegedFindClassByName(name);
                    clazz = AccessController.doPrivileged(dp);
                } else {
                    ////1. 先在Web应用目录下查找类
                    clazz = findClassInternal(name);
                }
            } catch(AccessControlException ace) {
                log.warn(sm.getString("webappClassLoader.securityException", name,
                        ace.getMessage()), ace);
                throw new ClassNotFoundException(name, ace);
            } catch (RuntimeException e) {
                if (log.isTraceEnabled())
                    log.trace("      -->RuntimeException Rethrown", e);
                throw e;
            }
            if ((clazz == null) && hasExternalRepositories) {
                try {
                    //2. 如果在本地目录没有找到，交给父加载器去查找
                    clazz = super.findClass(name);
                } catch(AccessControlException ace) {
                    log.warn(sm.getString("webappClassLoader.securityException", name,
                            ace.getMessage()), ace);
                    throw new ClassNotFoundException(name, ace);
                } catch (RuntimeException e) {
                    if (log.isTraceEnabled())
                        log.trace("      -->RuntimeException Rethrown", e);
                    throw e;
                }
            }
            if (clazz == null) {
                if (log.isDebugEnabled())
                    log.debug("    --> Returning ClassNotFoundException");
                throw new ClassNotFoundException(name);
            }
        } catch (ClassNotFoundException e) {
            if (log.isTraceEnabled())
                log.trace("    --> Passing on ClassNotFoundException");
            throw e;
        }

        // Return the class we have located
        if (log.isTraceEnabled())
            log.debug("      Returning class " + clazz);

        if (log.isTraceEnabled()) {
            ClassLoader cl;
            if (Globals.IS_SECURITY_ENABLED){
                cl = AccessController.doPrivileged(
                    new PrivilegedGetClassLoader(clazz));
            } else {
                cl = clazz.getClassLoader();
            }
            log.debug("      Loaded by " + cl.toString());
        }
        return clazz;

    }

```




# Tomcat 处理请求专题

上次说到了Connector里面含有组件NioEndpoint,我们就以这个开始。

1. NioEndPoint 里面含有组件Acceptor，Poller，Executor。
2. Acceptor此线程接受socket连接，然后直接通过setSocketOptions(socket)方法直接添加到Poller的events队列中。
3. Poller线程，处理socket的读写事件，通过hasEvents = events()把events队列中的连接注册到当前线程的selector多路复用器上，并监测当前连接的可读事件。一旦客户端有请求数据selector.selectedKeys().iterator(),获取所有有请求的连接进行数据处理。通过processSocket方法把连接请求传递给工作线程进行处理。也就是 executor.execute(sc).
4. 每一个executor线程，真正进行数据的读取会写以及业务处理。拿到上一步分装好的NioEndpoint的内部类SocketProcessor,工作线程会执行SocketProcessor的run方法.
5. 进而调用 getHandler().process(socketWrapper,SocketEvent.OPEN_READ)
6. ConnectionHandler.process(SocketWrapperBase < S > wrapper, SocketEvent status).
ConnectionHandler是Http11NioProtocol的顶层父类AbstractProtocol的内部类，在Http11NioProtocol的实例化过程的父类的构造方法，创建了ConnectionHandler的实例，并且赋值给了NioEndpoint。

此方法会将socket和Http11Processor放入map进行关联。

7. 由于此调用链过长，不再逐一列举，仅仅列举其中重要方法。
Http11Processor.service(SocketWrapperBase< ? >)

该方法会进行http协议的解析：

请求行解析：inputBuffer.parseRequestLine(keptAlive)

请求头解析：inputBuffer.parseHeaders()


8. CoyoteAdaper.service

此方法会匹配出当前请求的host,context,wrapper
通过postParseRequest进行匹配

connector.getService().getContainer().getPipeline.getFirst().invoke()

这里是执行tomcat容器的管道线模型

管道线执行结束，也就是业务处理完毕，进行相应数据的会写，service方法的最后会调用response.finishResponse方法进行数据回写。如果socket连接不可写，把当前socket注册到多路复用器（Block Poller线程），监测可写事件，然后加锁等待，直到通道可写，才进行解锁。


9. 最后回顾下上面说的容器的管道线模型调用过程。

StandardWrapperValva.invoke()

这个是容器最后的wrapper了，这个管道线后面会处理filter和service调用。

依次如下：

ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain()

filterChain.doFilter

doFilter为递归调用，业务Filter的doFilter方法的最后一定要调用filterChain.doFilter，不然调用链就会断掉，无法执行后续的filter和service。


internalDoFilter的最后会调用servlet的service方法。


