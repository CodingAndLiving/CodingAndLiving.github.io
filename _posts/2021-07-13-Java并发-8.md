---
layout:     post
title:      Java并发-8
subtitle:   Java并发系列
date:       2021-07-13
author:     CodingAndLiving
header-img: img/com01.jpg
catalog: true
tags:
    - Java并发
    - 原理
    - 底层
---
# 前言

> 在繁杂的世界，能够沉下心来，梳理下知识体系，其实是一件很放松的诗意。


# Fork/Join 框架
 Fork/Join 框架是 Java7 提供了的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后 得到大任务结果的框架。

 > 有点像是单机版本的mapreduce

 我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别 放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。 但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干 活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程 之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务 执行。

 工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里 只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。


 1. ForkJoinPool 的每个工作线程都维护着一个工作队列（WorkQueue），这是一个双端队列（Deque），里面存放的对象是任务 （ForkJoinTask）。 
 2. 每个工作线程在运行中产生新的任务（通常是因为调用了 fork()）时，会放入工作队列的队尾，并且工作线程在处理自己的工作 队列时，使用的是 LIFO 方式，也就是说每次从队尾取出任务来执行。 
 3. 每个工作线程在处理自己的工作队列同时，会尝试窃取一个任务（或是来自于刚刚提交到 pool 的任务，或是来自于其他工作线 程的工作队列），窃取的任务位于其他线程的工作队列的队首，也就是说工作线程在窃取其他工作线程的任务时，使用的是 FIFO 方式。 
 4. 在遇到 join() 时，如果需要 join 的任务尚未完成，则会先处理其他任务，并等待其完成。 

 5. 在既没有自己的任务，也没有可以窃取的任务时，进入休眠。


# 使用

ForkJoinTask：我们要使用 ForkJoin 框架，必须首先创建一个 ForkJoin 任务。它提供在任务中执行 fork() 和 join() 操作的机制，通 常情况下我们不需要直接继承 ForkJoinTask 类，而只需要继承它的子类，Fork/Join 框架提供了以下两个子类： 

RecursiveAction：用于没有返回结果的任务。

RecursiveTask ：用于有返回结果的任务。

CountedCompleter： 在任务完成执行后会触发执行一个自定义的钩子函数


> 这个没怎么用过，简单记录下，有这个东东就好了，不深入探究。


