---
layout:     post
title:      微服务实践-读书笔记
subtitle:   微服务实践-读书笔记
date:       2019-10-04
author:     CodingAndLiving
header-img: img/com01.jpg
catalog: true
tags:
    - 微服务
    - 架构
    - 实践
---
# 前言

> **本文**主要介绍了自身对于微服务的一些认识
（这篇笔记放在角落里太久了，久到我没有耐心读完这篇笔记，先保存者，后续批判分说。2021-02-18）

# 前提介绍
架构，从传统的单体mvc三层应用开始，到SOA、微服务、ServiceMesh，其实本质的手段就是拆分。

# 水平分层
样例：
app -> Nginx -> 网关 -> 业务逻辑 -> 数据访问 -> 数据存储（db）

原理：

1. 展示服务，跟 网关服务 分离，后台不处理显示的样式，例如日期是**YYYMMHH**还是**YYYYMMHH hh:mm:ss**,后端不关心这个，应该后端直接返回时间戳。
2. 网关服务跟逻辑服务分离。
3. 逻辑服务跟数据访问分离。
3. 分离后，可以专注于各自的功能和职责。
4. 网关层功能：
    1. 请求鉴权
    2. 数据完整性检查，例如数据包json格式为：定长的header + 不定长的body，header不是指网络协议的header，而是自身规定的，可以包含用户id，时间戳等
    3. 协议转换，例如json转化为hashmap，一般网关层之前的协议是http + json，之后的是tcp + 字节序列化，所以，json需要转化为map，再到字节序列化。
    4. 路由转发
    5. 服务治理
5. 数据访问层功能
	1. CRUD
	2. ORM，例如Mybatis Plus这些框架
	3. 分库分表，选择第三方sharding代理，还是将这个直接交给数据库。第三方代理，针对极大数据量，并且多维度查询的表，无法进行分表。数据库发展经历了关系型
	数据库，Nosql，再到现在的分布式数据库，那么不采取第三方sharding代理，例如采取Tidb，是否会更好。
	4. 屏蔽底层存储差异，不管是mysql，还是Oracle，还是redis。

# 同步架构和异步架构
区别就是是否加入了例如mq之类的作为缓冲。异步架构可以获得更高的吞吐量，但是平均响应延时会变长。从吞吐量优势出发，一般将mq放于网关和业务逻辑层之间。对于请求，
是否都可以采取mq，则不然。例如，get请求，一般不采取mq。则post请求，可以放到mq中，接着post请求直接返回用户ok。但是，也不是所有的post请求都适合mq，例如，我
post之后，需要get获取，但是之前post的还没到数据库，导致get查询数据库没有该数据。又或者，我post请求放到mq中，返回用户成功，接着mq消息写入数据层失败。

# 水平分层的全局样貌图

1. app先获取DNS，进行域名解析。
2. app获取cdn缓存，如果cdn缓存没成功，那么cdn会请求转发nginx获取css和html文件，请求转发到对象存储获取图片和音视频等文件。对象存储可以使用fastdfs或者其他。
3. app最后就是到nginx，网关...  这系列步骤了。

# SOA 
soa可以理解为是垂直分层。
1. 例如由不同业务的系统，这些系统都是单体war包。
2. 系统之间的数据交互通过esb来完成。
3. esb会压力特别大。


# 微服务架构
1. 其实是水平分层 + 垂直分层
2. 业务逻辑层之间不存在通信，逻辑层和数据访问层会存在通信。
3. 业务逻辑层由于相互之间不通信，所以为了避免代码冗余，划分为聚合业务层和公共业务逻辑层，严格确保通信方向只会从上到下，不会平行通信，避免平行通信带来的互相循环问题。
4. 微服务根据业务进行拆分，也会导致企业组织的架构变化，无非是职能部门向事业部的方向进行转变。
5. 微服务，更适合于需求变化频繁，迭代迅速，高吞吐量，以及最终一致性。
6. 一致性一般分为强一致性，和最终一致性。

# ServiceMesh
什么是serviceMesh？
微服务存在下面问题：
1. 业务需要关注服务之间的通信，不能专注于业务修改，影响迭代速度。
2. 基础设施升级困难，这个主要是当基础设施团队和业务团队是不同团队时候。
3. 微服务虽然支持多语言，多语言之间的通信都需要一套接口，繁琐。

为了解决这些问题，就是产生了ServiceMesh。
1. 业务团队专注于业务。
2. 服务通信交给基础设施团队。
3. 一套基础设施支持不同语言。
4. 基础设施下沉，形成独立的服务进程。



# 案例分析

#### 推送系统
1. 设计难点
	1. 采取pull还是push？ 人数极多情况下不支持push
	2. 同步还是异步？  异步吞吐量够大。

#### IM系统
1. 设计难点
	1. 千万人同时在线
	2. 同步还是异步？

	


# 负载均衡

1. 狭义的负载均衡，是指通过硬件手段或者软件手段，进行负载均衡，

2. 广义的负载均衡，还应该包括完整的故障处理恢复机制。

	1. 故障自动发现

		1. 应该有谁进行发现，网关，注册中心？，还是服务消费方？，抑或是注册中心，和 服务消费方的共同努力。

	2. 故障服务自动摘除

		1. 发现服务故障时候，是否应该提供自动重启手段，将故障的服务进行重启？

	3. 请求自动重试

	4. 服务恢复自动发现


# 服务幂等设计

1. 幂等，分为两种情况，分别是：

	1. 请求层面

		1.请求重复执行和执行一次的结果相同

	2. 业务层面：
	
		1. 同一个用户对于某些操作不可以重复执行，例如下单，转账。

2. 对于请求层面：

	1. 读写请求，只有写请求，需要处理幂等。

	2. 对于，网关层，逻辑层，数据访问层，明显的是，只有数据访问层才需要处理幂等。

	3. crud操作；

		1. create/insert操作，是不是幂等的？
		
		2. 答：如果insert操作，表中存在类似于唯一性的约束，导致重复执行，插入数据会报错，那么这就是幂等的；如果使用自增主键，就可以考虑不使用自增主键了，或使用序列生成器服务也可以。

		3. update操作是否幂等的？

		4. 答： 看下面两个例子，**update user set age=18 where uid=58 **  和  *update user set age++ where uid=58*,显然，是否幂等，取决于是否加上约束条件。

		5. delete操作是否幂等？

		6. 答：同理。


3. 对于业务层面：

	1. 由于冗余部署多个进程，存在并发消费的可能性。从而需要确保幂等。

	2. 方法一：例如执行下单或者转账之前，可以先判断状态，是否已经转账完成。

	3. 方法2： 本质上，是多个进程，对于共享的请求，发生了重复消费，可以利用分布式锁，控制并发，确保只有一个消费者。


# 分布式锁的设计

1. 分布式锁是为了，串行化，实现互斥。例如，防止用户重复下单，将用户id作为共享资源，实现互斥和串行化。除外，还可以用于MQ消费端的去重。

2. 注意，分布式锁的用途就是人为确定一个共享资源，造成互斥。

3. 基于redis的分布式锁。

	1. 好处，就是redis内部是单一线程，保证了串行化。 	

	2. 坏处就是：

		1. 锁时间不可控，无法续租期。

		2. 如果redis部署单实例，会存在非高可用；但是部署主从，又会存在数据不一致的问题。

	3. 所以，基于redis的分布式锁，适用于对于一致性要求不高的业务场景。

4. 分布式锁的设计目标

 	1. 强一致性。
 	2. 服务高可用
 	3. 锁自动续约，自动释放。
 	4. 代码高度抽象，业务接入简单。
 	5. 具备可视化的管理后台，监控及管理。

5. 存储产品对比：

 	1. redis：

 		1. 不具备一致性算法。

 		2. AP模型

 		3. 主从高可用

 		4. 接口类型是客户端。

 	2. zookeeper：

 		1. ZAB一致性算法

 		2. CP模型

 		3. N+1可用

 		4. 接口类型是客户端

 	3. etcd：

 		1. raft一致性算法

 		2. N+1可用

 		3. 接口类型是http/grpc 

 	业界用zookeeper实现分布式锁较少，用etcd较多。

6. 采取etcd实现分布式锁的方案

 	1. 采取分布式client和etcd实现。

 		1. client作为jar包提供。

 		2. etcd集中存储。

 		3. client实现续期。

 	2. 思路：

 		1. 客户端A，跟etcd拿锁。
 		2. 客户端B，跟etcd拿锁
 		3. A拿锁成功，B失败
 		4. A服务，需要跟etcd保持心跳，例如锁的租期是10s，每个三分之一时间，即3s，发起一次心跳，带上锁的识别号，后台续期。
 		5. 锁的清理：

 			1. 调用方，正常结束，调用delete方法进行锁释放。
 			2. 调用方，异常，心跳线程不存在，等待锁自动过期，就会释放。
 			3. 如果调用方，异常，但是心跳线程还在，则可以利用上面讲述的服务故障发现，重启服务，从而线程会自动断掉。

 		6. 锁的监控平台。例如可以看到获取锁的平均耗时。

 	3. etcd的兼容性测试

 		1. 假如etcd由三个节点组成集群。
 		2. 单节点停机，不影响读写，不影响一致性。
 		3. 当只有一个节点时候，读停机，写正常。
 		4. 理论上，只要不是多节点同时停机，线上服务不会受到影响。
 		5. etcd实现分布式锁，可采取v2版本。


# 分布式事务

1. 一个简单，但是不可靠的分布式事务实现方案

	1. 场景：

		1. 购物下单，发送消息到MQ

	2. 实现手段：

		1. 开启一个本地事务。

		2. 下单，操作数据库。

		3. 发送MQ

		4. 提交事务

		5. 以上步骤都位于try块

		6. catch块，里面如果异常，则回滚。

	3. 分析，如果发送MQ，没有报错，则顺利提交事务，否则，回滚事务。

	4. 貌似确实可以实现分布式事务，但是如果，mq抛出异常是timeout，导致事务回滚，但是timeout也可以是成功发送消息。这样子就会形成bug。


2. 分布式事务分类

	1. 刚性分布式事务，讲究强一致性。

		1. 基于XA模型
		2. XA模型，定义了应用程序（AP）、资源管理器（RM）、事务管理器（TM）
		3. AP定义事务边界
		4. RM管理计算机共享资源，例如数据库
		5. TM管理全局事务

	2. 柔性分布事务，基于base理论，讲究最终一致性。

3. 刚性分布式事务，实现方案

	1. 2PC方案，两阶段提交，简单来讲，就是真正提交之前，先来个prepare，大家都没问题后，统一进行真正的提交，如果在真正的提交时候，某个节点挂掉了，则给他单独准备补偿。

	2. 缺点： 

		1. 同步阻塞模型，锁定时间过长。

4. 柔性分布式事务，实现方案

	1. TCC方案

		1. TCC模型，完全交给业务实现，对于业务侵入大。

		2. 阶段一：尝试执行业务，预留必要的业务资源。

		3. 阶段二：真正执行。

		4. 阶段三：释放预留的业务资源。

		5. 以汇款作为案例

			1. try阶段：

				1. 检查用户A的有效性
				2. 从用户A中扣取五百块，设置状态为转帐中。
				3. 预留扣减资源，将该转账事件，记录于数据库或者MQ
			2. C阶段：

				1. 不做任何操作。

			3. C阶段：

				1. 用户A增加五百块
				2. 从数据库或者MQ中，去除转账事件。

	2. Saga方案

		1. 该方案的特点就是，将分布式事务转化为一系列的本地事务，依次执行，若失败，回滚。
		2. 回滚有两种方案：

			1. 往后回滚，按照执行顺序的逆序，进行回滚。

			2. 往前回滚，相当于重新执行一遍，达到成功目的。这里需要注意。操作必须都是幂等的。


5. 其实，上面解决方案说明了解决问题的本质。

	1. 要么解决这个问题本身，例如TCC方案，追求实现分布式事务。
	2. 要么让这个问题消失，例如Saga方案，追求不存在分布式事务，都是本地事务，


6. TCC的落地方案，基于MQ实现。

	1. 方案一

		1. 业务方A先MQ发送半消息，所谓半消息，既是还没有确认的消息，MQ受到确认之前，不会给消费方进行消费。
		2. MQ响应半消息发送成功。
		3. 业务方A进行确认，或者取消半消息。
		4. 确认后，MQ提供消息给消费者。
		5. 另外，为了保证消息都已经进行了二次确认，所以MQ内部会存在一个线程，循环检查还没有确认的消息，向业务方A进行询问。
		6. 业务方A检查本地事务的状态，从而告知MQ二次确认的结果是commit 还是 cancel。

		7. 方案一的优点，是可以通用，但是缺点是需要MQ支持半消息，并且业务方提供回查接口。另外消费端需要处理消息幂等。

	2. 方案二
	
		1. 业务方A操作业务数据时候，将业务数据写入数据库表，另外，还需要在发送MQ消息之前，将MQ消息写入消息表，两个操作要位于同一个事务。
		2. 从消息表中，读取消息，发送到mq
		3. 收到MQ的发送消息回执之后，删除消息表的消息。

		4. 方案二的优点是，MQ不需要支持半消息特性，业务方也不需要提供回查接口。

	3. 针对上面两种方案，都需要注意一个问题。就是业务方A发送消息成功，MQ投递消息给消费者也成功，但是消费者失败时候，如何处理？

	4. 这时候，消费者失败，需要记录相关的上下文信息，例如参数，记录报错日志，发送告警通知，人工介入。


7. Saga的落地解决方案

	1. Saga的思路是，让分布式事务不存在，都采取本地事务。
	2. 例如，下单，扣除库存，支付，这里不采取三个微服务，而是一个交易服务，调用了三个数据访问层。
	3. 将分布式事务，转为若干个本地事务。
	4. 关键点：

		1. 记录调用的参数。
		2. 失败，需要调用补偿接口。
		3. 补偿接口必须幂等。

